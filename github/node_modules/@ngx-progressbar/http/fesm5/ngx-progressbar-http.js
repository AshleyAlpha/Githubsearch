import { InjectionToken, Injectable, Optional, Inject, NgModule } from '@angular/core';
import { __assign } from 'tslib';
import { finalize } from 'rxjs/operators';
import { NgProgress } from '@ngx-progressbar/core';
import { HTTP_INTERCEPTORS } from '@angular/common/http';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var NG_PROGRESS_HTTP_CONFIG = new InjectionToken('ngProgressHttpConfig');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressInterceptor = /** @class */ (function () {
    function NgProgressInterceptor(ngProgress, config) {
        this._inProgressCount = 0;
        this._config = {
            id: 'root',
            silentApis: []
        };
        this._config = config ? __assign({}, this._config, config) : this._config;
        this._progressRef = ngProgress.ref(this._config.id);
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    NgProgressInterceptor.prototype.intercept = /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    function (req, next) {
        var _this = this;
        // Ignore by request headers
        if (req.headers.has('ignoreProgressBar')) {
            return next.handle(req.clone({ headers: req.headers.delete('ignoreProgressBar') }));
        }
        // Ignore silent api requests
        if (this.checkUrl(req)) {
            return next.handle(req);
        }
        this._inProgressCount++;
        if (!this._progressRef.isStarted) {
            this._progressRef.start();
        }
        return next.handle(req).pipe(finalize(function () {
            _this._inProgressCount--;
            if (_this._inProgressCount === 0) {
                _this._progressRef.complete();
            }
        }));
    };
    /**
     * Check if request is silent.
     * @param {?} req request
     * @return {?}
     */
    NgProgressInterceptor.prototype.checkUrl = /**
     * Check if request is silent.
     * @param {?} req request
     * @return {?}
     */
    function (req) {
        /** @type {?} */
        var url = req.url.toLowerCase();
        /** @type {?} */
        var found = this._config.silentApis.find(function (u) { return url.startsWith(u); });
        return !!found;
    };
    NgProgressInterceptor.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NgProgressInterceptor.ctorParameters = function () { return [
        { type: NgProgress },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_HTTP_CONFIG,] }] }
    ]; };
    return NgProgressInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressHttpModule = /** @class */ (function () {
    function NgProgressHttpModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    NgProgressHttpModule.withConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: NgProgressHttpModule,
            providers: [
                { provide: NG_PROGRESS_HTTP_CONFIG, useValue: config }
            ]
        };
    };
    NgProgressHttpModule.decorators = [
        { type: NgModule, args: [{
                    providers: [
                        { provide: HTTP_INTERCEPTORS, useClass: NgProgressInterceptor, multi: true }
                    ]
                },] }
    ];
    return NgProgressHttpModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgProgressHttpModule, NG_PROGRESS_HTTP_CONFIG as ɵc, NgProgressInterceptor as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByb2dyZXNzYmFyLWh0dHAuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvaHR0cC9saWIvbmctcHJvZ3Jlc3MtaHR0cC5pbnRlcmZhY2UudHMiLCJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvaHR0cC9saWIvbmctcHJvZ3Jlc3MuaW50ZXJjZXB0b3IudHMiLCJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvaHR0cC9saWIvbmctcHJvZ3Jlc3MtaHR0cC5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmdQcm9ncmVzc0h0dHBDb25maWcge1xyXG4gIGlkPzogc3RyaW5nO1xyXG4gIHNpbGVudEFwaXM/OiBzdHJpbmdbXTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE5HX1BST0dSRVNTX0hUVFBfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuPE5nUHJvZ3Jlc3NIdHRwQ29uZmlnPignbmdQcm9ncmVzc0h0dHBDb25maWcnKTtcclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBIdHRwSW50ZXJjZXB0b3IsIEh0dHBFdmVudCwgSHR0cEhhbmRsZXIsIEh0dHBSZXF1ZXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGZpbmFsaXplIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzLCBOZ1Byb2dyZXNzUmVmIH0gZnJvbSAnQG5neC1wcm9ncmVzc2Jhci9jb3JlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0h0dHBDb25maWcsIE5HX1BST0dSRVNTX0hUVFBfQ09ORklHIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy1odHRwLmludGVyZmFjZSc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xyXG5cclxuICBwcml2YXRlIF9pblByb2dyZXNzQ291bnQgPSAwO1xyXG4gIHByaXZhdGUgX3Byb2dyZXNzUmVmOiBOZ1Byb2dyZXNzUmVmO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbmZpZzogTmdQcm9ncmVzc0h0dHBDb25maWcgPSB7XHJcbiAgICBpZDogJ3Jvb3QnLFxyXG4gICAgc2lsZW50QXBpczogW11cclxuICB9O1xyXG5cclxuICBjb25zdHJ1Y3RvcihuZ1Byb2dyZXNzOiBOZ1Byb2dyZXNzLCBAT3B0aW9uYWwoKSBASW5qZWN0KE5HX1BST0dSRVNTX0hUVFBfQ09ORklHKSBjb25maWc/OiBOZ1Byb2dyZXNzSHR0cENvbmZpZykge1xyXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnID8gey4uLnRoaXMuX2NvbmZpZywgLi4uY29uZmlnfSA6IHRoaXMuX2NvbmZpZztcclxuICAgIHRoaXMuX3Byb2dyZXNzUmVmID0gbmdQcm9ncmVzcy5yZWYodGhpcy5fY29uZmlnLmlkKTtcclxuICB9XHJcblxyXG4gIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xyXG5cclxuICAgIC8vIElnbm9yZSBieSByZXF1ZXN0IGhlYWRlcnNcclxuICAgIGlmIChyZXEuaGVhZGVycy5oYXMoJ2lnbm9yZVByb2dyZXNzQmFyJykpIHtcclxuICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcS5jbG9uZSh7aGVhZGVyczogcmVxLmhlYWRlcnMuZGVsZXRlKCdpZ25vcmVQcm9ncmVzc0JhcicpfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElnbm9yZSBzaWxlbnQgYXBpIHJlcXVlc3RzXHJcbiAgICBpZiAodGhpcy5jaGVja1VybChyZXEpKSB7XHJcbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2luUHJvZ3Jlc3NDb3VudCsrO1xyXG5cclxuICAgIGlmICghdGhpcy5fcHJvZ3Jlc3NSZWYuaXNTdGFydGVkKSB7XHJcbiAgICAgIHRoaXMuX3Byb2dyZXNzUmVmLnN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSkucGlwZShcclxuICAgICAgZmluYWxpemUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2luUHJvZ3Jlc3NDb3VudC0tO1xyXG4gICAgICAgIGlmICh0aGlzLl9pblByb2dyZXNzQ291bnQgPT09IDApIHtcclxuICAgICAgICAgIHRoaXMuX3Byb2dyZXNzUmVmLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHJlcXVlc3QgaXMgc2lsZW50LlxyXG4gICAqIEBwYXJhbSByZXEgcmVxdWVzdFxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2hlY2tVcmwocmVxOiBIdHRwUmVxdWVzdDxhbnk+KSB7XHJcbiAgICBjb25zdCB1cmwgPSByZXEudXJsLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBmb3VuZCA9IHRoaXMuX2NvbmZpZy5zaWxlbnRBcGlzLmZpbmQoKHUpID0+IHVybC5zdGFydHNXaXRoKHUpKTtcclxuICAgIHJldHVybiAhIWZvdW5kO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBOZ01vZHVsZSwgTW9kdWxlV2l0aFByb3ZpZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBIVFRQX0lOVEVSQ0VQVE9SUyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0ludGVyY2VwdG9yIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmNlcHRvcic7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NIdHRwQ29uZmlnLCBOR19QUk9HUkVTU19IVFRQX0NPTkZJRyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtaHR0cC5pbnRlcmZhY2UnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHsgcHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsIHVzZUNsYXNzOiBOZ1Byb2dyZXNzSW50ZXJjZXB0b3IsIG11bHRpOiB0cnVlIH1cclxuICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzSHR0cE1vZHVsZSB7XHJcbiAgc3RhdGljIHdpdGhDb25maWcoY29uZmlnOiBOZ1Byb2dyZXNzSHR0cENvbmZpZyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IE5nUHJvZ3Jlc3NIdHRwTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICB7IHByb3ZpZGU6IE5HX1BST0dSRVNTX0hUVFBfQ09ORklHLCB1c2VWYWx1ZTogY29uZmlnIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQU9BLElBQWEsdUJBQXVCLEdBQUcsSUFBSSxjQUFjLENBQXVCLHNCQUFzQixDQUFDOzs7Ozs7O0lDVXJHLCtCQUFZLFVBQXNCLEVBQStDLE1BQTZCO2dDQVBuRixDQUFDO3VCQUVxQjtZQUMvQyxFQUFFLEVBQUUsTUFBTTtZQUNWLFVBQVUsRUFBRSxFQUFFO1NBQ2Y7UUFHQyxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sZ0JBQU8sSUFBSSxDQUFDLE9BQU8sRUFBSyxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUNwRSxJQUFJLENBQUMsWUFBWSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNyRDs7Ozs7O0lBRUQseUNBQVM7Ozs7O0lBQVQsVUFBVSxHQUFxQixFQUFFLElBQWlCO1FBQWxELGlCQTBCQzs7UUF2QkMsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1lBQ3hDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbkY7O1FBR0QsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3RCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN6QjtRQUVELElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRXhCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRTtZQUNoQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQzNCO1FBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDMUIsUUFBUSxDQUFDO1lBQ1AsS0FBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDeEIsSUFBSSxLQUFJLENBQUMsZ0JBQWdCLEtBQUssQ0FBQyxFQUFFO2dCQUMvQixLQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQzlCO1NBQ0YsQ0FBQyxDQUNILENBQUM7S0FDSDs7Ozs7O0lBTU8sd0NBQVE7Ozs7O2NBQUMsR0FBcUI7O1FBQ3BDLElBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7O1FBQ2xDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUEsQ0FBQyxDQUFDO1FBQ3JFLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQzs7O2dCQWxEbEIsVUFBVTs7OztnQkFIRixVQUFVO2dEQWFvQixRQUFRLFlBQUksTUFBTSxTQUFDLHVCQUF1Qjs7Z0NBakJqRjs7Ozs7OztBQ0FBOzs7Ozs7O0lBV1MsK0JBQVU7Ozs7SUFBakIsVUFBa0IsTUFBNEI7UUFDNUMsT0FBTztZQUNMLFFBQVEsRUFBRSxvQkFBb0I7WUFDOUIsU0FBUyxFQUFFO2dCQUNULEVBQUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUU7YUFDdkQ7U0FDRixDQUFDO0tBQ0g7O2dCQWJGLFFBQVEsU0FBQztvQkFDUixTQUFTLEVBQUU7d0JBQ1QsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsUUFBUSxFQUFFLHFCQUFxQixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7cUJBQzdFO2lCQUNGOzsrQkFURDs7Ozs7Ozs7Ozs7Ozs7OyJ9