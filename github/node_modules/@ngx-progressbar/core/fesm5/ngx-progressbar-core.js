import { __assign, __read } from 'tslib';
import { Subject, BehaviorSubject, timer, of, combineLatest, Subscription } from 'rxjs';
import { tap, map, skip, delay, filter, debounce, switchMap, distinctUntilChanged } from 'rxjs/operators';
import { InjectionToken, Injectable, Inject, Optional, NgModule, Component, Input, Output, ChangeDetectionStrategy, EventEmitter, ViewEncapsulation, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressRef = /** @class */ (function () {
    function NgProgressRef(customConfig, _onDestroyCallback) {
        var _this = this;
        this._onDestroyCallback = _onDestroyCallback;
        /**
         * Stream that increments and updates progress state
         */
        this._trickling = new Subject();
        /**
         * Stream that combines "_trickling" and "config" streams
         */
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return timer(start ? config.debounceTime : 0);
        }), switchMap(function (_a) {
            var _b = __read(_a, 2), start = _b[0], config = _b[1];
            return start ? _this.onTrickling(config) : _this.onComplete(config);
        })).subscribe();
    }
    Object.defineProperty(NgProgressRef.prototype, "currState", {
        get: /**
         * Get current progress state
         * @return {?}
         */
        function () {
            return this._state.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        /** Check if progress has started */
        get: /**
         * Check if progress has started
         * @return {?}
         */
        function () {
            return this.currState.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "started", {
        /** Progress start event */
        get: /**
         * Progress start event
         * @return {?}
         */
        function () {
            return this._state.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return active; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "completed", {
        /** Progress ended event */
        get: /**
         * Progress ended event
         * @return {?}
         */
        function () {
            return this._state.pipe(map(function (state) { return state.active; }), distinctUntilChanged(), filter(function (active) { return !active; }), skip(1));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start the progress
     */
    /**
     * Start the progress
     * @return {?}
     */
    NgProgressRef.prototype.start = /**
     * Start the progress
     * @return {?}
     */
    function () {
        this._trickling.next(true);
    };
    /**
     * Complete the progress
     */
    /**
     * Complete the progress
     * @return {?}
     */
    NgProgressRef.prototype.complete = /**
     * Complete the progress
     * @return {?}
     */
    function () {
        this._trickling.next(false);
    };
    /**
     * Increment the progress
     * @param amount
     */
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    NgProgressRef.prototype.inc = /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    };
    /**
     * Set the progress
     * @param n
     */
    /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.set = /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.setState({ value: this.clamp(n), active: true });
    };
    /**
     * Set config
     * @param config
     */
    /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.setConfig = /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this._config.next(__assign({}, this._config.value, config));
    };
    /**
     * Destroy progress reference
     */
    /**
     * Destroy progress reference
     * @return {?}
     */
    NgProgressRef.prototype.destroy = /**
     * Destroy progress reference
     * @return {?}
     */
    function () {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this._onDestroyCallback();
    };
    /**
     * Set progress state
     * @param {?} state
     * @return {?}
     */
    NgProgressRef.prototype.setState = /**
     * Set progress state
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this._state.next(__assign({}, this.currState, state));
    };
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.clamp = /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    function (n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    };
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onTrickling = /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap(function () { return _this.inc(); }));
    };
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onComplete = /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        return !this.isStarted ? of({}) : of({}).pipe(
        // Completes the progress
        tap(function () { return _this.setState({ value: 100 }); }), 
        // Hides the progress bar after a tiny delay
        delay(config.speed * 1.7), tap(function () { return _this.setState({ active: false }); }), 
        // Resets the progress state
        delay(config.speed), tap(function () { return _this.setState({ value: 0 }); }));
    };
    return NgProgressRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var NG_PROGRESS_CONFIG = new InjectionToken('ngProgressConfig');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ɵ0 = function (n) {
    if (n >= 0 && n < 20)
        return 10;
    if (n >= 20 && n < 50)
        return 4;
    if (n >= 50 && n < 80)
        return 2;
    if (n >= 80 && n < 99)
        return 0.5;
    return 0;
};
/** @type {?} */
var defaultConfig = {
    min: 8,
    max: 100,
    speed: 200,
    debounceTime: 0,
    trickleSpeed: 300,
    fixed: true,
    meteor: true,
    thick: false,
    spinner: true,
    ease: 'linear',
    color: '#1B95E0',
    direction: 'ltr+',
    spinnerPosition: 'right',
    trickleFunc: ɵ0
};
var NgProgress = /** @class */ (function () {
    function NgProgress(config) {
        /**
         * Store progress bar instances
         */
        this._instances = new Map();
        this.config = config ? __assign({}, defaultConfig, config) : defaultConfig;
    }
    /**
     * Get or Create progress bar by ID
     * @param id
     * @param config
     */
    /**
     * Get or Create progress bar by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    NgProgress.prototype.ref = /**
     * Get or Create progress bar by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    function (id, config) {
        if (id === void 0) { id = 'root'; }
        if (this._instances.has(id)) {
            /** @type {?} */
            var progressRef = this._instances.get(id);
            if (config) {
                progressRef.setConfig(__assign({}, this.config, config));
            }
            return progressRef;
        }
        else {
            /** @type {?} */
            var progressRef = new NgProgressRef(__assign({}, this.config, config), this.deleteInstance(id));
            return this._instances.set(id, progressRef).get(id);
        }
    };
    /**
     * Destroy all progress bar instances
     */
    /**
     * Destroy all progress bar instances
     * @return {?}
     */
    NgProgress.prototype.destroyAll = /**
     * Destroy all progress bar instances
     * @return {?}
     */
    function () {
        this._instances.forEach(function (ref) { return ref.destroy(); });
    };
    /**
     * A destroyer function for each progress bar instance
     * @param {?} id
     * @return {?}
     */
    NgProgress.prototype.deleteInstance = /**
     * A destroyer function for each progress bar instance
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var _this = this;
        return function () {
            _this._instances.delete(id);
        };
    };
    NgProgress.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NgProgress.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_CONFIG,] }] }
    ]; };
    /** @nocollapse */ NgProgress.ngInjectableDef = defineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(inject(NG_PROGRESS_CONFIG, 8)); }, token: NgProgress, providedIn: "root" });
    return NgProgress;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressComponent = /** @class */ (function () {
    function NgProgressComponent(_ngProgress) {
        this._ngProgress = _ngProgress;
        this._started = Subscription.EMPTY;
        this._completed = Subscription.EMPTY;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.min = this._ngProgress.config.min;
        this.max = this._ngProgress.config.max;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.speed = this._ngProgress.config.speed;
        this.thick = this._ngProgress.config.thick;
        this.fixed = this._ngProgress.config.fixed;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    Object.defineProperty(NgProgressComponent.prototype, "isStarted", {
        get: /**
         * @return {?}
         */
        function () {
            return this.progressRef.isStarted;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        // Subscribe to progress state
        this.state$ = this.progressRef.state.pipe(map(function (state) { return ({
            active: state.active,
            transform: "translate3d(" + state.value + "%,0,0)"
        }); }));
        // Subscribes to started and completed events on deman
        if (this.started.observers.length) {
            this._started = this.progressRef.started.subscribe(function () { return _this.started.emit(); });
        }
        if (this.completed.observers.length) {
            this._completed = this.progressRef.completed.subscribe(function () { return _this.completed.emit(); });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._started.unsubscribe();
        this._completed.unsubscribe();
        this.progressRef.destroy();
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.start = /**
     * @return {?}
     */
    function () {
        this.progressRef.start();
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.complete = /**
     * @return {?}
     */
    function () {
        this.progressRef.complete();
    };
    /**
     * @param {?=} n
     * @return {?}
     */
    NgProgressComponent.prototype.inc = /**
     * @param {?=} n
     * @return {?}
     */
    function (n) {
        this.progressRef.inc(n);
    };
    /**
     * @param {?} n
     * @return {?}
     */
    NgProgressComponent.prototype.set = /**
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.progressRef.set(n);
    };
    NgProgressComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng-progress',
                    host: {
                        'role': 'progressbar',
                        '[attr.spinnerPosition]': 'spinnerPosition',
                        '[attr.dir]': 'direction',
                        '[attr.thick]': 'thick',
                        '[attr.fixed]': 'fixed'
                    },
                    template: "\n    <ng-container *ngIf=\"state$ | async; let state\">\n      <div class=\"ng-progress-bar\"\n            [class.-active]=\"state.active\"\n            [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\n        <div class=\"ng-bar-placeholder\">\n          <div class=\"ng-bar\"\n                [style.transform]=\"state.transform\"\n                [style.backgroundColor]=\"color\"\n                [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\n          </div>\n        </div>\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\n          <div class=\"ng-spinner-icon\"\n                [style.borderTopColor]=\"color\"\n                [style.borderLeftColor]=\"color\"></div>\n        </div>\n      </div>\n    </ng-container>\n  ",
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    styles: ["ng-progress{z-index:999999;pointer-events:none}ng-progress[fixed=true] .ng-progress-bar,ng-progress[fixed=true] .ng-spinner{position:fixed}ng-progress[fixed=true] .ng-spinner{top:15px}ng-progress[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}ng-progress[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}ng-progress[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}ng-progress[thick=true] .ng-bar-placeholder{height:3px!important}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}ng-progress[dir='ltr+'][thick=true] .ng-meteor,ng-progress[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}ng-progress[dir='ltr+'] .ng-bar,ng-progress[dir='rtl+'] .ng-bar{margin-left:-100%}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir='rtl+'] .ng-meteor{right:0}ng-progress[dir='ltr+'] .ng-meteor,ng-progress[dir=rtl-] .ng-meteor{top:-3px}ng-progress[dir='ltr+'][thick=true] .ng-meteor,ng-progress[dir=rtl-][thick=true] .ng-meteor{top:-4px}ng-progress[dir='rtl+'] .ng-meteor,ng-progress[dir=ltr-] .ng-meteor{bottom:-3px}ng-progress[dir='rtl+'][thick=true] .ng-meteor,ng-progress[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}ng-progress[dir='rtl+'] .ng-bar-placeholder,ng-progress[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}ng-progress[dir='rtl+'] .ng-spinner-icon,ng-progress[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}ng-progress[dir='rtl+'] .ng-meteor,ng-progress[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}ng-progress[dir='rtl+'][thick=true] .ng-meteor,ng-progress[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}ng-progress[spinnerPosition=left] .ng-spinner{left:10px}ng-progress[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar.-active{opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:250ms linear infinite spinner-animation;animation:250ms linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
                }] }
    ];
    /** @nocollapse */
    NgProgressComponent.ctorParameters = function () { return [
        { type: NgProgress }
    ]; };
    NgProgressComponent.propDecorators = {
        id: [{ type: Input }],
        min: [{ type: Input }],
        max: [{ type: Input }],
        ease: [{ type: Input }],
        color: [{ type: Input }],
        speed: [{ type: Input }],
        thick: [{ type: Input }],
        fixed: [{ type: Input }],
        meteor: [{ type: Input }],
        spinner: [{ type: Input }],
        trickleSpeed: [{ type: Input }],
        debounceTime: [{ type: Input }],
        trickleFunc: [{ type: Input }],
        spinnerPosition: [{ type: Input }],
        direction: [{ type: Input }],
        started: [{ type: Output }],
        completed: [{ type: Output }]
    };
    return NgProgressComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgProgressModule = /** @class */ (function () {
    function NgProgressModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    NgProgressModule.withConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: NG_PROGRESS_CONFIG, useValue: config }
            ]
        };
    };
    NgProgressModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [NgProgressComponent],
                    exports: [NgProgressComponent],
                    imports: [CommonModule]
                },] }
    ];
    return NgProgressModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgProgressModule, NgProgressComponent, NgProgressRef, NgProgress, NG_PROGRESS_CONFIG };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByb2dyZXNzYmFyLWNvcmUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtcHJvZ3Jlc3NiYXIvY29yZS9saWIvbmctcHJvZ3Jlc3MtcmVmLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmludGVyZmFjZS50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LXByb2dyZXNzYmFyL2NvcmUvbGliL25nLXByb2dyZXNzLmNvbXBvbmVudC50cyIsIm5nOi8vQG5neC1wcm9ncmVzc2Jhci9jb3JlL2xpYi9uZy1wcm9ncmVzcy5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdQcm9ncmVzc1N0YXRlLCBOZ1Byb2dyZXNzQ29uZmlnIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBCZWhhdmlvclN1YmplY3QsIHRpbWVyLCBvZiwgY29tYmluZUxhdGVzdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRhcCwgbWFwLCBza2lwLCBkZWxheSwgZmlsdGVyLCBkZWJvdW5jZSwgc3dpdGNoTWFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzUmVmIHtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcHJvZ3Jlc3Mgc3RhdGUgaXMgY2hhbmdlZCAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3N0YXRlOiBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc1N0YXRlPjtcclxuICBzdGF0ZTogT2JzZXJ2YWJsZTxOZ1Byb2dyZXNzU3RhdGU+O1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBjb25maWcgaXMgY2hhbmdlZCAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbmZpZzogQmVoYXZpb3JTdWJqZWN0PE5nUHJvZ3Jlc3NDb25maWc+O1xyXG4gIGNvbmZpZzogT2JzZXJ2YWJsZTxOZ1Byb2dyZXNzU3RhdGU+O1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgaW5jcmVtZW50cyBhbmQgdXBkYXRlcyBwcm9ncmVzcyBzdGF0ZSAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3RyaWNrbGluZyA9IG5ldyBTdWJqZWN0KCk7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBjb21iaW5lcyBcIl90cmlja2xpbmdcIiBhbmQgXCJjb25maWdcIiBzdHJlYW1zICovXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfd29ya2VyID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICAvKiogR2V0IGN1cnJlbnQgcHJvZ3Jlc3Mgc3RhdGUgKi9cclxuICBwcml2YXRlIGdldCBjdXJyU3RhdGUoKTogTmdQcm9ncmVzc1N0YXRlIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZS52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKiBDaGVjayBpZiBwcm9ncmVzcyBoYXMgc3RhcnRlZCAqL1xyXG4gIGdldCBpc1N0YXJ0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyU3RhdGUuYWN0aXZlO1xyXG4gIH1cclxuXHJcbiAgLyoqIFByb2dyZXNzIHN0YXJ0IGV2ZW50ICovXHJcbiAgZ2V0IHN0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUucGlwZShcclxuICAgICAgbWFwKChzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSA9PiBzdGF0ZS5hY3RpdmUpLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBmaWx0ZXIoYWN0aXZlID0+IGFjdGl2ZSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKiogUHJvZ3Jlc3MgZW5kZWQgZXZlbnQgKi9cclxuICBnZXQgY29tcGxldGVkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkgPT4gc3RhdGUuYWN0aXZlKSxcclxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgZmlsdGVyKGFjdGl2ZSA9PiAhYWN0aXZlKSxcclxuICAgICAgc2tpcCgxKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGN1c3RvbUNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZywgcHJpdmF0ZSBfb25EZXN0cm95Q2FsbGJhY2s6IEZ1bmN0aW9uKSB7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc1N0YXRlPih7YWN0aXZlOiBmYWxzZSwgdmFsdWU6IDB9KTtcclxuICAgIHRoaXMuX2NvbmZpZyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TmdQcm9ncmVzc0NvbmZpZz4oY3VzdG9tQ29uZmlnKTtcclxuICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9zdGF0ZS5hc09ic2VydmFibGUoKTtcclxuICAgIHRoaXMuY29uZmlnID0gdGhpcy5fc3RhdGUuYXNPYnNlcnZhYmxlKCk7XHJcblxyXG4gICAgdGhpcy5fd29ya2VyID0gY29tYmluZUxhdGVzdCh0aGlzLl90cmlja2xpbmcsIHRoaXMuX2NvbmZpZykucGlwZShcclxuICAgICAgZGVib3VuY2UoKFtzdGFydCwgY29uZmlnXTogW2Jvb2xlYW4sIE5nUHJvZ3Jlc3NDb25maWddKSA9PiB0aW1lcihzdGFydCA/IGNvbmZpZy5kZWJvdW5jZVRpbWUgOiAwKSksXHJcbiAgICAgIHN3aXRjaE1hcCgoW3N0YXJ0LCBjb25maWddOiBbYm9vbGVhbiwgTmdQcm9ncmVzc0NvbmZpZ10pID0+IHN0YXJ0ID8gdGhpcy5vblRyaWNrbGluZyhjb25maWcpIDogdGhpcy5vbkNvbXBsZXRlKGNvbmZpZykpXHJcbiAgICApLnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLl90cmlja2xpbmcubmV4dCh0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBsZXRlIHRoZSBwcm9ncmVzc1xyXG4gICAqL1xyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nLm5leHQoZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVtZW50IHRoZSBwcm9ncmVzc1xyXG4gICAqIEBwYXJhbSBhbW91bnRcclxuICAgKi9cclxuICBpbmMoYW1vdW50PzogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBuID0gdGhpcy5jdXJyU3RhdGUudmFsdWU7XHJcbiAgICBpZiAoIXRoaXMuaXNTdGFydGVkKSB7XHJcbiAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGFtb3VudCA9IHRoaXMuX2NvbmZpZy52YWx1ZS50cmlja2xlRnVuYyhuKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldChuICsgYW1vdW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgcHJvZ3Jlc3NcclxuICAgKiBAcGFyYW0gblxyXG4gICAqL1xyXG4gIHNldChuOiBudW1iZXIpIHtcclxuICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiB0aGlzLmNsYW1wKG4pLCBhY3RpdmU6IHRydWV9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBjb25maWdcclxuICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICovXHJcbiAgc2V0Q29uZmlnKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgdGhpcy5fY29uZmlnLm5leHQoey4uLnRoaXMuX2NvbmZpZy52YWx1ZSwgLi4uY29uZmlnfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IHByb2dyZXNzIHJlZmVyZW5jZVxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl93b3JrZXIudW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX3RyaWNrbGluZy5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fc3RhdGUuY29tcGxldGUoKTtcclxuICAgIHRoaXMuX2NvbmZpZy5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fb25EZXN0cm95Q2FsbGJhY2soKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwcm9ncmVzcyBzdGF0ZVxyXG4gICAqIEBwYXJhbSBzdGF0ZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgc2V0U3RhdGUoc3RhdGU6IE5nUHJvZ3Jlc3NTdGF0ZSkge1xyXG4gICAgdGhpcy5fc3RhdGUubmV4dCh7Li4udGhpcy5jdXJyU3RhdGUsIC4uLnN0YXRlfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIG1pbiBhbmQgbWF4XHJcbiAgICogQHBhcmFtIG5cclxuICAgKi9cclxuICBwcml2YXRlIGNsYW1wKG46IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5fY29uZmlnLnZhbHVlLm1pbiwgTWF0aC5taW4odGhpcy5fY29uZmlnLnZhbHVlLm1heCwgbikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogS2VlcHMgaW5jcmVtZW50aW5nIHRoZSBwcm9ncmVzc1xyXG4gICAqIEBwYXJhbSBjb25maWdcclxuICAgKi9cclxuICBwcml2YXRlIG9uVHJpY2tsaW5nKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcbiAgICBpZiAoIXRoaXMuaXNTdGFydGVkKSB7XHJcbiAgICAgIHRoaXMuc2V0KHRoaXMuX2NvbmZpZy52YWx1ZS5taW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpbWVyKDAsIGNvbmZpZy50cmlja2xlU3BlZWQpLnBpcGUodGFwKCgpID0+IHRoaXMuaW5jKCkpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBsZXRlcyB0aGVuIHJlc2V0cyB0aGUgcHJvZ3Jlc3NcclxuICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvbkNvbXBsZXRlKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gIXRoaXMuaXNTdGFydGVkID8gb2Yoe30pIDogb2Yoe30pLnBpcGUoXHJcbiAgICAgIC8vIENvbXBsZXRlcyB0aGUgcHJvZ3Jlc3NcclxuICAgICAgdGFwKCgpID0+IHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiAxMDB9KSksXHJcblxyXG4gICAgICAvLyBIaWRlcyB0aGUgcHJvZ3Jlc3MgYmFyIGFmdGVyIGEgdGlueSBkZWxheVxyXG4gICAgICBkZWxheShjb25maWcuc3BlZWQgKiAxLjcpLFxyXG4gICAgICB0YXAoKCkgPT4gdGhpcy5zZXRTdGF0ZSh7YWN0aXZlOiBmYWxzZX0pKSxcclxuXHJcbiAgICAgIC8vIFJlc2V0cyB0aGUgcHJvZ3Jlc3Mgc3RhdGVcclxuICAgICAgZGVsYXkoY29uZmlnLnNwZWVkKSxcclxuICAgICAgdGFwKCgpID0+IHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiAwfSkpXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOZ1Byb2dyZXNzU3RhdGUge1xyXG4gIGFjdGl2ZT86IGJvb2xlYW47XHJcbiAgdmFsdWU/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmdQcm9ncmVzc0NvbmZpZyB7XHJcbiAgc3Bpbm5lclBvc2l0aW9uPzogJ2xlZnQnIHwgJ3JpZ2h0JztcclxuICBkaXJlY3Rpb24/OiAnbHRyKycgfCAnbHRyLScgfCAncnRsKycgfCAncnRsLSc7XHJcbiAgZWFzZT86IHN0cmluZztcclxuICBjb2xvcj86IHN0cmluZztcclxuICB0aGljaz86IGJvb2xlYW47XHJcbiAgZml4ZWQ/OiBib29sZWFuO1xyXG4gIG1ldGVvcj86IGJvb2xlYW47XHJcbiAgc3Bpbm5lcj86IGJvb2xlYW47XHJcbiAgbWF4PzogbnVtYmVyO1xyXG4gIG1pbj86IG51bWJlcjtcclxuICBzcGVlZD86IG51bWJlcjtcclxuICB0cmlja2xlU3BlZWQ/OiBudW1iZXI7XHJcbiAgdHJpY2tsZUZ1bmM/OiAobjogbnVtYmVyKSA9PiBudW1iZXI7XHJcbiAgZGVib3VuY2VUaW1lPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTkdfUFJPR1JFU1NfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuPE5nUHJvZ3Jlc3NDb25maWc+KCduZ1Byb2dyZXNzQ29uZmlnJyk7XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtcmVmJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc0NvbmZpZywgTkdfUFJPR1JFU1NfQ09ORklHIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5pbnRlcmZhY2UnO1xyXG5cclxuY29uc3QgZGVmYXVsdENvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyA9IHtcclxuICBtaW46IDgsXHJcbiAgbWF4OiAxMDAsXHJcbiAgc3BlZWQ6IDIwMCxcclxuICBkZWJvdW5jZVRpbWU6IDAsXHJcbiAgdHJpY2tsZVNwZWVkOiAzMDAsXHJcbiAgZml4ZWQ6IHRydWUsXHJcbiAgbWV0ZW9yOiB0cnVlLFxyXG4gIHRoaWNrOiBmYWxzZSxcclxuICBzcGlubmVyOiB0cnVlLFxyXG4gIGVhc2U6ICdsaW5lYXInLFxyXG4gIGNvbG9yOiAnIzFCOTVFMCcsXHJcbiAgZGlyZWN0aW9uOiAnbHRyKycsXHJcbiAgc3Bpbm5lclBvc2l0aW9uOiAncmlnaHQnLFxyXG4gIHRyaWNrbGVGdW5jOiAobjogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgIGlmIChuID49IDAgJiYgbiA8IDIwKSByZXR1cm4gMTA7XHJcbiAgICBpZiAobiA+PSAyMCAmJiBuIDwgNTApIHJldHVybiA0O1xyXG4gICAgaWYgKG4gPj0gNTAgJiYgbiA8IDgwKSByZXR1cm4gMjtcclxuICAgIGlmIChuID49IDgwICYmIG4gPCA5OSkgcmV0dXJuIDAuNTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufTtcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3Mge1xyXG5cclxuICAvKiogU3RvcmUgcHJvZ3Jlc3MgYmFyIGluc3RhbmNlcyAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2luc3RhbmNlcyA9IG5ldyBNYXA8c3RyaW5nLCBOZ1Byb2dyZXNzUmVmPigpO1xyXG5cclxuICAvKiogR2xvYmFsIGNvbmZpZyAqL1xyXG4gIGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZztcclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChOR19QUk9HUkVTU19DT05GSUcpIGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZykge1xyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWcgPyB7Li4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnfSA6IGRlZmF1bHRDb25maWc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3IgQ3JlYXRlIHByb2dyZXNzIGJhciBieSBJRFxyXG4gICAqIEBwYXJhbSBpZFxyXG4gICAqIEBwYXJhbSBjb25maWdcclxuICAgKi9cclxuICByZWYoaWQgPSAncm9vdCcsIGNvbmZpZz86IE5nUHJvZ3Jlc3NDb25maWcpIHtcclxuICAgIGlmICh0aGlzLl9pbnN0YW5jZXMuaGFzKGlkKSkge1xyXG4gICAgICAvLyBHZXQgUHJvZ3Jlc3NSZWYgaW5zdGFuY2VcclxuICAgICAgY29uc3QgcHJvZ3Jlc3NSZWYgPSB0aGlzLl9pbnN0YW5jZXMuZ2V0KGlkKTtcclxuICAgICAgaWYgKGNvbmZpZykge1xyXG4gICAgICAgIHByb2dyZXNzUmVmLnNldENvbmZpZyh7Li4udGhpcy5jb25maWcsIC4uLmNvbmZpZ30pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwcm9ncmVzc1JlZjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENyZWF0ZSBuZXcgUHJvZ3Jlc3NSZWYgaW5zdGFuY2VcclxuICAgICAgY29uc3QgcHJvZ3Jlc3NSZWYgPSBuZXcgTmdQcm9ncmVzc1JlZih7Li4udGhpcy5jb25maWcsIC4uLmNvbmZpZ30sIHRoaXMuZGVsZXRlSW5zdGFuY2UoaWQpKTtcclxuICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlcy5zZXQoaWQsIHByb2dyZXNzUmVmKS5nZXQoaWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveSBhbGwgcHJvZ3Jlc3MgYmFyIGluc3RhbmNlc1xyXG4gICAqL1xyXG4gIGRlc3Ryb3lBbGwoKSB7XHJcbiAgICB0aGlzLl9pbnN0YW5jZXMuZm9yRWFjaCgocmVmOiBOZ1Byb2dyZXNzUmVmKSA9PiByZWYuZGVzdHJveSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZGVzdHJveWVyIGZ1bmN0aW9uIGZvciBlYWNoIHByb2dyZXNzIGJhciBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZGVsZXRlSW5zdGFuY2UoaWQ6IHN0cmluZykge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgdGhpcy5faW5zdGFuY2VzLmRlbGV0ZShpZCk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBPbkNoYW5nZXMsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIFZpZXdFbmNhcHN1bGF0aW9uXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiwgU3Vic2NyaXB0aW9uTGlrZX0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzcyB9IGZyb20gJy4vbmctcHJvZ3Jlc3Muc2VydmljZSc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NSZWYgfSBmcm9tICcuL25nLXByb2dyZXNzLXJlZic7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NTdGF0ZSB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbmctcHJvZ3Jlc3MnLFxyXG4gIGhvc3Q6IHtcclxuICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcclxuICAgICdbYXR0ci5zcGlubmVyUG9zaXRpb25dJzogJ3NwaW5uZXJQb3NpdGlvbicsXHJcbiAgICAnW2F0dHIuZGlyXSc6ICdkaXJlY3Rpb24nLFxyXG4gICAgJ1thdHRyLnRoaWNrXSc6ICd0aGljaycsXHJcbiAgICAnW2F0dHIuZml4ZWRdJzogJ2ZpeGVkJ1xyXG4gIH0sXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJzdGF0ZSQgfCBhc3luYzsgbGV0IHN0YXRlXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJuZy1wcm9ncmVzcy1iYXJcIlxyXG4gICAgICAgICAgICBbY2xhc3MuLWFjdGl2ZV09XCJzdGF0ZS5hY3RpdmVcIlxyXG4gICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvbl09XCInb3BhY2l0eSAnICsgc3BlZWQgKyAnbXMgJyArIGVhc2VcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwibmctYmFyLXBsYWNlaG9sZGVyXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmctYmFyXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS50cmFuc2Zvcm1dPVwic3RhdGUudHJhbnNmb3JtXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiY29sb3JcIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLnRyYW5zaXRpb25dPVwic3RhdGUuYWN0aXZlID8gJ2FsbCAnICsgc3BlZWQgKyAnbXMgJyArIGVhc2UgOiAnbm9uZSdcIj5cclxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cIm1ldGVvclwiIGNsYXNzPVwibmctbWV0ZW9yXCIgW3N0eWxlLmJveFNoYWRvd109XCInMCAwIDEwcHggJysgY29sb3IgKyAnLCAwIDAgNXB4ICcgKyBjb2xvclwiPjwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiAqbmdJZj1cInNwaW5uZXJcIiBjbGFzcz1cIm5nLXNwaW5uZXJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZy1zcGlubmVyLWljb25cIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJvcmRlclRvcENvbG9yXT1cImNvbG9yXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXJMZWZ0Q29sb3JdPVwiY29sb3JcIj48L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L25nLWNvbnRhaW5lcj5cclxuICBgLFxyXG4gIHN0eWxlVXJsczogWycuL25nLXByb2dyZXNzLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3NDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcclxuXHJcbiAgcHJpdmF0ZSBfc3RhcnRlZDogU3Vic2NyaXB0aW9uTGlrZSA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcclxuICBwcml2YXRlIF9jb21wbGV0ZWQ6IFN1YnNjcmlwdGlvbkxpa2UgPSBTdWJzY3JpcHRpb24uRU1QVFk7XHJcblxyXG4gIC8qKiBQcm9ncmVzcyBiYXIgd29ya2VyICovXHJcbiAgcHJvZ3Jlc3NSZWY6IE5nUHJvZ3Jlc3NSZWY7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyBwcm9ncmVzcyBzdGF0ZSAqL1xyXG4gIHN0YXRlJDogT2JzZXJ2YWJsZTx7IGFjdGl2ZTogYm9vbGVhbiwgdHJhbnNmb3JtOiBzdHJpbmcgfT47XHJcblxyXG4gIC8qKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGlmIGlkIGlzIG5vdCBhbHJlYWR5IGV4aXN0cyAqL1xyXG4gIEBJbnB1dCgpIGlkID0gJ3Jvb3QnO1xyXG5cclxuICAvKiogSW5pdGlhbGl6ZXMgaW5wdXRzIGZyb20gdGhlIGdsb2JhbCBjb25maWcgKi9cclxuICBASW5wdXQoKSBtaW46IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1pbjtcclxuICBASW5wdXQoKSBtYXg6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1heDtcclxuICBASW5wdXQoKSBlYXNlOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5lYXNlO1xyXG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5jb2xvcjtcclxuICBASW5wdXQoKSBzcGVlZDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3BlZWQ7XHJcbiAgQElucHV0KCkgdGhpY2s6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50aGljaztcclxuICBASW5wdXQoKSBmaXhlZDogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmZpeGVkO1xyXG4gIEBJbnB1dCgpIG1ldGVvcjogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1ldGVvcjtcclxuICBASW5wdXQoKSBzcGlubmVyOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3Bpbm5lcjtcclxuICBASW5wdXQoKSB0cmlja2xlU3BlZWQ6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRyaWNrbGVTcGVlZDtcclxuICBASW5wdXQoKSBkZWJvdW5jZVRpbWU6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmRlYm91bmNlVGltZTtcclxuICBASW5wdXQoKSB0cmlja2xlRnVuYzogKG46IG51bWJlcikgPT4gbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcudHJpY2tsZUZ1bmM7XHJcbiAgQElucHV0KCkgc3Bpbm5lclBvc2l0aW9uOiAnbGVmdCcgfCAncmlnaHQnID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3Bpbm5lclBvc2l0aW9uO1xyXG4gIEBJbnB1dCgpIGRpcmVjdGlvbjogJ2x0cisnIHwgJ2x0ci0nIHwgJ3J0bCsnIHwgJ3J0bC0nID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZGlyZWN0aW9uO1xyXG4gIEBPdXRwdXQoKSBzdGFydGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIEBPdXRwdXQoKSBjb21wbGV0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gIGdldCBpc1N0YXJ0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzc1JlZi5pc1N0YXJ0ZWQ7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1Byb2dyZXNzOiBOZ1Byb2dyZXNzKSB7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcygpIHtcclxuICAgIGlmICh0aGlzLnByb2dyZXNzUmVmIGluc3RhbmNlb2YgTmdQcm9ncmVzc1JlZikge1xyXG4gICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgYmFyIGNvbmZpZyB3aGVuIGlucHV0cyBjaGFuZ2VcclxuICAgICAgdGhpcy5wcm9ncmVzc1JlZi5zZXRDb25maWcoe1xyXG4gICAgICAgIG1heDogKHRoaXMubWF4ID4gMCAmJiB0aGlzLm1heCA8PSAxMDApID8gdGhpcy5tYXggOiAxMDAsXHJcbiAgICAgICAgbWluOiAodGhpcy5taW4gPCAxMDAgJiYgdGhpcy5taW4gPj0gMCkgPyB0aGlzLm1pbiA6IDAsXHJcbiAgICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgICAgdHJpY2tsZVNwZWVkOiB0aGlzLnRyaWNrbGVTcGVlZCxcclxuICAgICAgICB0cmlja2xlRnVuYzogdGhpcy50cmlja2xlRnVuYyxcclxuICAgICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICAvLyBHZXQgcHJvZ3Jlc3MgYmFyIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYgPSB0aGlzLl9uZ1Byb2dyZXNzLnJlZih0aGlzLmlkLCB7XHJcbiAgICAgIG1heDogdGhpcy5tYXgsXHJcbiAgICAgIG1pbjogdGhpcy5taW4sXHJcbiAgICAgIHNwZWVkOiB0aGlzLnNwZWVkLFxyXG4gICAgICB0cmlja2xlU3BlZWQ6IHRoaXMudHJpY2tsZVNwZWVkLFxyXG4gICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJvZ3Jlc3Mgc3RhdGVcclxuICAgIHRoaXMuc3RhdGUkID0gdGhpcy5wcm9ncmVzc1JlZi5zdGF0ZS5waXBlKFxyXG4gICAgICBtYXAoKHN0YXRlOiBOZ1Byb2dyZXNzU3RhdGUpID0+ICh7XHJcbiAgICAgICAgYWN0aXZlOiBzdGF0ZS5hY3RpdmUsXHJcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtzdGF0ZS52YWx1ZX0lLDAsMClgXHJcbiAgICAgIH0pKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmVzIHRvIHN0YXJ0ZWQgYW5kIGNvbXBsZXRlZCBldmVudHMgb24gZGVtYW5cclxuICAgIGlmICh0aGlzLnN0YXJ0ZWQub2JzZXJ2ZXJzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9zdGFydGVkID0gdGhpcy5wcm9ncmVzc1JlZi5zdGFydGVkLnN1YnNjcmliZSgoKSA9PiB0aGlzLnN0YXJ0ZWQuZW1pdCgpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbXBsZXRlZC5vYnNlcnZlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX2NvbXBsZXRlZCA9IHRoaXMucHJvZ3Jlc3NSZWYuY29tcGxldGVkLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNvbXBsZXRlZC5lbWl0KCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9zdGFydGVkLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB0aGlzLl9jb21wbGV0ZWQudW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuZGVzdHJveSgpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLnByb2dyZXNzUmVmLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICBjb21wbGV0ZSgpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuY29tcGxldGUoKTtcclxuICB9XHJcblxyXG4gIGluYyhuPzogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnByb2dyZXNzUmVmLmluYyhuKTtcclxuICB9XHJcblxyXG4gIHNldChuOiBudW1iZXIpIHtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWYuc2V0KG4pO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzQ29tcG9uZW50IH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzQ29uZmlnLCBOR19QUk9HUkVTU19DT05GSUcgfSBmcm9tICcuL25nLXByb2dyZXNzLmludGVyZmFjZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGRlY2xhcmF0aW9uczogW05nUHJvZ3Jlc3NDb21wb25lbnRdLFxyXG4gIGV4cG9ydHM6IFtOZ1Byb2dyZXNzQ29tcG9uZW50XSxcclxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdQcm9ncmVzc01vZHVsZSB7XHJcbiAgc3RhdGljIHdpdGhDb25maWcoY29uZmlnOiBOZ1Byb2dyZXNzQ29uZmlnKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogTmdQcm9ncmVzc01vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAge3Byb3ZpZGU6IE5HX1BST0dSRVNTX0NPTkZJRywgdXNlVmFsdWU6IGNvbmZpZ31cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7SUFJQTtJQTZDRSx1QkFBWSxZQUE4QixFQUFVLGtCQUE0QjtRQUFoRixpQkFVQztRQVZtRCx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQVU7Ozs7MEJBbENsRCxJQUFJLE9BQU8sRUFBRTs7Ozt1QkFHaEIsWUFBWSxDQUFDLEtBQUs7UUFnQzNDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxlQUFlLENBQWtC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